sample = FilePath "day18/sample.txt"
input = FilePath "day18/input.txt"


structural type Dir = Up | Down | Left | Right

structural type Instruction = {direction: Dir, length: Nat, color: Text}

Dir.fromText : Text -> Dir
Dir.fromText = cases 
    "U" -> Up
    "D" -> Down
    "L" -> Left
    "R" -> Right
    s -> bug ("Invalid direction: ", s)

Instruction.pat = Pattern.join [
        , capture (chars "UDLR")
        , space
        , capture (some patterns.digit), 
        , space
        , literal "(#"
        , capture (some patterns.hexDigit)
        , literal ")"
    ]


fromInt = Int.toNat >> Optional.getOrElse 0

dig : [Instruction] -> Nat
dig insts = Scope.run do
    use mutable.ByteArray write8 read8
    (fromX', toX', fromY', toY') = borders insts
    fromX = fromX' - +1
    fromY = fromY' - +1
    toX = toX' + +2
    toY = toY' + +2
    sizeX = toX - fromX |> fromInt
    sizeY = toY - fromY |> fromInt
    arr = Scope.byteArrayOf 0 (sizeX * sizeY)
    index x y = fromInt (x - fromX) * sizeY + fromInt (y - fromY)
    paint c x y = write8 arr (index x y) c
    (lastX, lastY) = List.foldLeft (p i -> walk' (paint 1) p i) (+0, +0) insts
    paint 1 lastX lastY
    inside x y = (x >= fromX) && (x < toX) && (y >= fromY) && (y < toY)
    goto x y = when (inside x y && (read8 arr (index x y) == 0)) do
        paint 2 x y
        emit (x, y)
    floodfill : [(Int, Int)] -> ()
    floodfill ls = if List.isEmpty ls then () else 
        do List.foreach ls (cases (x, y) -> 
            goto (x - +1) y
            goto (x + +1) y
            goto x (y - +1)
            goto x (y + +1)
        ) |> toList! |> floodfill
    charAt x y = match read8 arr (x * sizeY + y) with 
        1 -> ?#
        2 -> ?% 
        _ -> ?.
    floodfill [(fromX, fromY)]
    lst = List.range 0 sizeX |> List.map (x -> List.range 0 sizeY |> List.map (charAt x) |> fromCharList)
    Debug.trace "map" lst
    Stream.range 0 (sizeX * sizeY) |> Stream.map (read8 arr >> (x -> if x == 2 then 0 else 1)) |> fold! (+) 0


walk : (Int, Int) -> Instruction -> {} (Int, Int)
walk = walk' (x y -> ())

walk' : (Int -> Int -> {e} ()) -> (Int, Int) -> Instruction -> {e} (Int, Int)
walk' act = cases 
    (x, y), Instruction dir len _ -> 
        len' = Nat.toInt len
        match dir with
            Up ->
                forIn 0 len (i -> act (x - Nat.toInt i) y) 
                (x - len', y)
            Down ->
                forIn 0 len (i -> act (x + Nat.toInt i) y) 
                (x + len', y)
            Left -> 
                forIn 0 len (i -> act x (y - Nat.toInt i))
                (x, y - len')
            Right ->
                forIn 0 len (i -> act x (y + Nat.toInt i)) 
                (x , y +  len')

borders : [Instruction] -> (Int, Int, Int, Int)
borders = 
        use Int max min
        List.foldLeft ( cases 
            ((fromX, toX, fromY, toY), xy), inst  -> 
                xy@(x', y') = walk xy inst
                ((min fromX x', max toX x', min fromY y', max toY y'), xy)
            ) ((+0, +0, +0, +0), (+0, +0)) >> at1

parse : Text -> [Instruction]
parse = lines >> List.map (captures Instruction.pat >> cases
        [dir, len, color] -> Instruction (Dir.fromText dir) (Nat.fromText len |> getOrBug ("bad length", len)) color
        ss -> bug ("bad instruction", ss)
    )

run1 = readFileUtf8 >> parse >> dig |> delay

s1 = run1 sample
i1 = run1 input