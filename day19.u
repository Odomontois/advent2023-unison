
structural type Decision = Accept | Reject | SendTo Text
structural type Sign = GT | LT
structural type Attribute = X | M | A | S
structural type Rule = { attr : Attribute, sign : Sign, value : Nat, decision : Decision}
structural type WorkFlow = {name: Text, rules: [Rule], default: Decision}
structural type Item = {items : data.Array Nat}

Item.get : Item -> Attribute ->{Exception} Nat
Item.get it = (Item.items it |> data.Array.read) << cases 
    X -> 0
    M -> 1
    A -> 2
    S -> 3

Rule.cmp : Rule -> Nat -> Nat -> Boolean
Rule.cmp = Rule.sign >> cases 
    GT -> (Nat.>)
    LT -> (Nat.<)

Rule.decide : Rule -> Item -> Optional Decision
Rule.decide rule item = 
    val = Item.get item (Rule.attr rule)
    if Rule.cmp rule val (Rule.value rule)
    then Some (Rule.decision rule)
    else None

parse.nameP = capture (some asciiLetter)
parse.num = capture (some patterns.digit)
parse.ruleP = Pattern.join [nameP, capture (chars "<>"), num, chars ":", nameP, comma]
parse.comma = literal ","
parse.wfP = Pattern.join [nameP, literal "{", some (capture ruleP), nameP, literal "}"]
parse.assignmentP = Pattern.join [some asciiLetter, literal "=", num]
parse.itemP = Pattern.join [literal "{", sepMany comma assignmentP, literal "}"]
parse.attr = cases 
        "x" -> X
        "m" -> M
        "a" -> A
        "s" -> S
        x -> raiseGeneric "bad attr" x
parse.sign = cases
        ">" -> GT
        "<" -> LT
        x -> raiseGeneric "bad sign" x
parse.value x = Nat.fromText x |> getOrElse' '(raiseGeneric "bad value" x)
parse.rule = captures ruleP >> cases 
        [attrT, signT, valT, decT] -> Rule (attr attrT) (parse.sign signT) (parse.value valT) (parse.decision decT)
        x -> raiseGeneric "bad rule" x

parse.decision = cases
        "A" -> Accept
        "R" -> Reject
        x -> SendTo x
parse.workflow txt = captures wfP txt |> cases 
       (name +: ruleT) :+ default -> WorkFlow name (List.map parse.rule ruleT) (parse.decision default)
       x -> raiseGeneric "bad workflow" txt
parse.item = captures itemP >> List.map parse.value >> Array.fromList >> Item

parse : Text -> {Exception} ([WorkFlow], [Item])
parse = lines >> List.split (Text.isEmpty) >> cases 
        [workflows, items] -> (List.map workflow workflows, List.map item items)
        x -> raiseGeneric "bad parse" x

accepted : [WorkFlow] -> [Item] -> [Item]
accepted wfs = 
    wfm = List.map (WorkFlow.name &&& id) wfs |> Map.fromList
    forName name = Map.get name wfm |> getOrBug ("unknown wf", name)
    run item = 
       act default = cases
            (rule +: rules) -> 
                match Rule.decide rule item with
                    Some d -> d
                    None -> act default rules                
            [] -> default 

       forName >> (WorkFlow.default &&& WorkFlow.rules) >> uncurry act >> cases
            Accept -> true
            Reject -> false
            SendTo x -> run item x
    List.filter (flip run "in")

rating : Item -> Nat
rating = Item.items >> Array.foldLeft (+) 0


sample = FilePath "day19/sample.txt"
input = FilePath "day19/input.txt"

run1 = readFileUtf8 >> parse >>  uncurry accepted >> List.map rating >> List.foldLeft (+) 0 |> delay

s1 = run1 sample
i1 = run1 input

structural type ItemRange = { items: data.ByteArray }

use data ByteArray
write16be : data.ByteArray -> Nat -> Nat -> data.ByteArray
write16be arr i n = 
    high = n / 256
    low = mod n 256
    data.ByteArray.write8 arr i high |> (b -> data.ByteArray.write8 b (i + 1) low)

ItemRange.split : ItemRange -> Rule -> {Exception} (Optional ItemRange, Optional ItemRange)
ItemRange.split ir rule = 
    val  = Rule.value rule
    arr = ItemRange.items ir
    sign = Rule.sign rule

    idx i = 
        low = ByteArray.read16be arr i
        high =  ByteArray.read16be arr (i + 2)
        from v = Some (ItemRange (write16be arr i v))
        to v = Some (ItemRange (write16be arr (i + 2) v))
        match sign with 
            GT | val < low -> (Some ir, None)
               | val == low -> (from (val + 1), None) 
               | val >= high -> (None, None)
               | otherwise -> (from (val + 1), to val)
            LT | val > high -> (Some ir, None)
               | val == high -> (to (val - 1), None) 
               | val <= low -> (None, None)
               | otherwise -> (to (val - 1), from val)

    match Rule.attr rule with 
        X -> idx 0
        M -> idx 4
        A -> idx 8
        S -> idx 12

ItemRange.rating : ItemRange ->{Exception} Nat
ItemRange.rating ir = 
    arr = ItemRange.items ir
    at i = ByteArray.read16be arr i
    of i = at (i + 2) + 1 - at i
    of 0 * of 4 * of 8 * of 12

ItemRange.show : ItemRange -> Text
ItemRange.show ir = 
    use Text ++
    arr = ItemRange.items ir
    at i = ByteArray.read16be arr i |> Nat.toText
    of i =  at i ++ " to " ++ at (i + 2) 
    "{x: " ++ of 0 ++ ", m: " ++ of 4 ++ ", a: " ++ of 8 ++ ", s: " ++ of 12 ++ "}"



ranges : [WorkFlow] -> ItemRange -> '{Stream ItemRange, Exception} ()
ranges wfs = 
    wfm = List.map (WorkFlow.name &&& id) wfs |> Map.fromList
    forName name = Map.get name wfm |> getOrBug ("unknown wf", name)
    decide ir = cases 
        Accept -> 
            -- Debug.trace "accept" (show ir, ItemRange.rating ir)
            emit ir
        Reject -> 
            -- Debug.trace "reject" (show ir)
            ()
        SendTo x -> run x ir

    act ir default = cases
        (rule +: rules) -> 
            (ok, next) = ItemRange.split ir rule
            -- Debug.trace "split" (show ir, rule, ok |> map show, next |> map show)
            match ok with 
                Some ir' -> decide ir' (Rule.decision rule)
                None -> ()       
            match next with
                Some ir' -> act ir' default rules
                None -> () 
        [] -> decide ir default 

    run name = 
        wf = forName name
        default = WorkFlow.default wf
        rules = WorkFlow.rules wf
        ir -> act ir default rules
    run "in" |> delay



ItemRange.initial = ItemRange (List.range 0 4 |> List.flatMap '[0, 1, 4000 / 256, mod 4000 256] |> ByteArray.fromList)

> catch do ItemRange.initial |> ItemRange.rating
> pow 4000  4

run2 = readFileUtf8 >> parse >> at1 
        >> flip ranges initial 
        -- >> delay (Stream.foreach ((show &&& ItemRange.rating &&& emit) >> Debug.trace "accept"))
        >> Stream.map ItemRange.rating 
        >> fold! (+) 0 |> delay


> 919061735797000000 > 316132305330500000
s2 = run2 sample
i2 = run2 input